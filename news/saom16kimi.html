<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Enhanced Answer Sheet Scanner</title>
  <style>
    :root {
      --primary-color: #2c3e50;
      --success-color: #27ae60;
      --danger-color: #e74c3c;
      --warning-color: #f1c40f;
      --background-color: #ecf0f1;
      --panel-color: white;
      --border-color: #ddd;
    }

    body {
      font-family: 'Segoe UI', sans-serif;
      margin: 20px;
      background-color: var(--background-color);
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      color: var(--primary-color);
      margin-bottom: 30px;
    }

    .panel {
      background-color: var(--panel-color);
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 20px;
      margin-bottom: 20px;
    }

    .config-panel {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .config-panel input[type="number"],
    .config-panel button,
    .controls button {
      margin-right: 10px;
      padding: 8px 15px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      cursor: pointer;
    }

    .export-btn {
      background-color: var(--success-color);
      color: white;
      border-color: var(--success-color);
    }

    .export-btn:hover {
      background-color: #219653;
    }

    .start-btn {
      background-color: #007bff;
      color: white;
      border-color: #007bff;
    }

    .start-btn:hover {
      background-color: #0056b3;
    }

    .stop-btn {
      background-color: var(--danger-color);
      color: white;
      border-color: var(--danger-color);
    }

    .stop-btn:hover {
      background-color: #c82333;
    }

    #answerSheetContainer {
      text-align: center;
      display: none;
    }

    #answerSheetCanvas {
      border: 1px solid var(--border-color);
      max-width: 100%;
      height: auto;
    }

    #cameraContainer {
      position: relative;
    }

    #cameraPreview {
      width: 100%;
      height: 400px;
      background-color: #000;
    }

    #captureCanvas,
    #binaryCanvas {
      display: none;
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }

    #cameraOverlayResults {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      z-index: 10;
      font-size: 0.9em;
    }

    .score-display {
      font-size: 1.1em;
      font-weight: bold;
      margin-bottom: 5px;
    }

    #questionStats {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .question-result {
      border: 1px solid var(--border-color);
      padding: 8px;
      border-radius: 4px;
    }

    .correct {
      border-left: 4px solid var(--success-color);
    }

    .incorrect {
      border-left: 4px solid var(--danger-color);
    }

    .aggregate-item {
      border: 1px solid var(--border-color);
      padding: 8px;
      margin-right: 10px;
      margin-bottom: 10px;
      border-radius: 4px;
      background-color: var(--panel-color);
    }

    #floatingMessageContainer {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 1001;
    }

    .message {
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px 15px;
      border-radius: 5px;
      margin-bottom: 10px;
      opacity: 1;
      transition: opacity 0.5s ease-in-out;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Enhanced Answer Sheet Scanner</h1>
    
    <div class="panel config-panel">
      <input type="number" id="questionCount" placeholder="Total Questions" value="100" min="1" max="200">
      <input type="number" id="optionCount" placeholder="Options per Question" value="4" min="2" max="10">
      <input type="number" id="studentIdDigits" placeholder="Student ID Digits" value="10" min="1" max="20">
      <input type="number" id="scorePerQuestion" placeholder="Score per Question" value="1" min="1">
      <button id="generateBtn">Generate Answer Sheet</button>
      <button id="setAnswerKeyBtn">Set Answer Key</button>
      <button class="export-btn" id="exportImgBtn">Export Sheet Image</button>
    </div>

    <div id="answerSheetContainer" class="panel">
      <canvas id="answerSheetCanvas" width="595" height="842"></canvas>
    </div>

    <div id="cameraContainer" class="panel hide">
      <video id="cameraPreview" autoplay></video>
      <canvas id="captureCanvas" width="640" height="480"></canvas>
      <canvas id="binaryCanvas" width="640" height="480"></canvas>
      <div class="controls">
        <button class="start-btn" id="startCameraBtn">Start Camera</button>
        <button class="stop-btn" id="stopCameraBtn">Stop Camera</button>
        <button id="capturePhotoBtn">Capture & Scan</button>
        <button id="toggleFullscreenBtn">Toggle Fullscreen</button>
      </div>
      <div id="cameraOverlayResults" style="display: none;">
        <div class="score-display">Total Score: <span id="overlayTotalScore">0</span></div>
        <div id="overlayQuestionStats"></div>
      </div>
    </div>

    <div id="results" class="panel hide">
      <div class="score-display">Score: <span id="totalScore">0</span></div>
      <div id="questionStats"></div>
      <button class="scan-save-btn" id="saveResultBtn">Save Result</button>
    </div>

    <div id="aggregate" class="panel hide">
      <h3>Aggregate Statistics</h3>
      <div id="aggregateStats"></div>
      <button class="stats-btn" id="hideAggregateBtn">Close Stats</button>
    </div>

    <div class="controls">
      <button id="showCameraBtn">Show Camera</button>
      <button id="showAggregateBtn">Show All Results</button>
    </div>
  </div>

  <div id="floatingMessageContainer"></div>

  <script async src="https://docs.opencv.org/4.5.3/opencv.js" onload="onOpenCvReady();"></script>
  <script>
    "use strict";

    // Configuration and state management
    const state = {
      videoStream: null,
      isCameraActive: false,
      answerKey: [],
      studentAnswers: [],
      allStudentResults: [],
      opencvReady: false,
      debugMode: true
    };

    const config = {
      ANSWER_SHEET: {
        sheetWidth: 595,
        sheetHeight: 842,
        nameY: 40,
        classY: 65,
        studentIdY: 90,
        instructionsY: 120,
        studentIdLabelY: 160,
        studentIdStartX: 30,
        studentIdBoxSize: 10,
        studentIdBoxSpacing: 2,
        questionsStartX: 170,
        answerStartY: 30,
        verticalSpacingBetweenQuestions: 20,
        horizontalSpacingBetweenOptions: 22,
        boxSize: 12,
        optionOffsetX: 8,
        questionsPerColumn: 22,
        columnSpacing: 15,
        markerSize: 8,
        markerMargin: 12
      },
      PROCESSING: {
        OPTION_THRESHOLD: 0.55,
        BLUR_SIZE: new cv.Size(5, 5),
        ADAPTIVE_THRESHOLD: {
          blockSize: 11,
          C: 2,
          method: cv.ADAPTIVE_THRESH_GAUSSIAN_C,
          type: cv.THRESH_BINARY_INV
        },
        MORPH_KERNEL: cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3))
      }
    };

    // Core image processing functions
    const ImageProcessor = {
      preprocess: (src) => {
        const gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        cv.GaussianBlur(gray, gray, config.PROCESSING.BLUR_SIZE, 0);
        const binary = new cv.Mat();
        cv.adaptiveThreshold(
          gray, binary, 255,
          config.PROCESSING.ADAPTIVE_THRESHOLD.method,
          config.PROCESSING.ADAPTIVE_THRESHOLD.type,
          config.PROCESSING.ADAPTIVE_THRESHOLD.blockSize,
          config.PROCESSING.ADAPTIVE_THRESHOLD.C
        );
        cv.morphologyEx(binary, binary, cv.MORPH_CLOSE, config.PROCESSING.MORPH_KERNEL);
        gray.delete();
        return binary;
      },

      detectMarkers: (binary) => {
        const contours = new cv.MatVector();
        const hierarchy = new cv.Mat();
        cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
        const markers = [];
        for (let i = 0; i < contours.size(); i++) {
          const cnt = contours.get(i);
          const area = cv.contourArea(cnt);
          if (area > 50 && area < 300) {
            const approx = new cv.Mat();
            const epsilon = 0.02 * cv.arcLength(cnt, true);
            cv.approxPolyDP(cnt, approx, epsilon, true);
            if (approx.rows === 4) {
              markers.push(approx);
            }
            approx.delete();
          }
        }
        hierarchy.delete();
        contours.delete();
        return markers;
      },

      warpPerspective: (src, markers) => {
        const srcPoints = cv.matFromArray(4, 1, cv.CV_32FC2, markers.flatMap(m => [
          m.data32F[0], m.data32F[1], 
          m.data32F[2], m.data32F[3],
          m.data32F[4], m.data32F[5],
          m.data32F[6], m.data32F[7]
        ]));
        
        const dstPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
          0, 0,
          config.ANSWER_SHEET.sheetWidth, 0,
          config.ANSWER_SHEET.sheetWidth, config.ANSWER_SHEET.sheetHeight / 2,
          0, config.ANSWER_SHEET.sheetHeight / 2
        ]);
        
        const M = cv.getPerspectiveTransform(srcPoints, dstPoints);
        const warped = new cv.Mat();
        cv.warpPerspective(src, warped, M, new cv.Size(config.ANSWER_SHEET.sheetWidth, config.ANSWER_SHEET.sheetHeight / 2));
        srcPoints.delete();
        dstPoints.delete();
        M.delete();
        return warped;
      }
    };

    // Business logic
    class AnswerSheetScanner {
      static async initializeCamera() {
        try {
          state.videoStream = await navigator.mediaDevices.getUserMedia({
            video: { width: 1280, height: 720, facingMode: "environment" }
          });
          const video = document.getElementById('cameraPreview');
          video.srcObject = state.videoStream;
          video.play();
          state.isCameraActive = true;
        } catch (err) {
          console.error('Camera initialization failed:', err);
          this.showFloatingMessage('无法访问摄像头，请检查权限设置');
        }
      }

      static processFrame() {
        if (!state.isCameraActive || !state.opencvReady) return;
        
        const startTime = performance.now();
        const video = document.getElementById('cameraPreview');
        const canvas = document.getElementById('captureCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.drawImage(video, 0, 0);
        
        const src = cv.imread(canvas);
        const binary = ImageProcessor.preprocess(src);
        const markers = ImageProcessor.detectMarkers(binary);
        
        if (markers.length >= 4) {
          const warped = ImageProcessor.warpPerspective(src, markers);
          this.analyzeAnswers(warped);
          warped.delete();
        } else {
          this.fallbackAnalysis(src);
        }
        
        src.delete();
        binary.delete();
        this.updatePerformanceStats(startTime);
      }

      static analyzeAnswers(warpedImage) {
        const questionCount = parseInt(document.getElementById('questionCount').value) || 10;
        const optionCount = parseInt(document.getElementById('optionCount').value) || 4;
        state.studentAnswers = Array.from({ length: questionCount }, () => ({ answer: null, score: 0 }));
        
        const gray = new cv.Mat();
        cv.cvtColor(warpedImage, gray, cv.COLOR_RGBA2GRAY);
        const binary = new cv.Mat();
        cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);
        
        const options = ['A', 'B', 'C', 'D'];
        const config = config.ANSWER_SHEET;
        
        for (let i = 0; i < questionCount; i++) {
          const row = i % config.questionsPerColumn;
          const col = Math.floor(i / config.questionsPerColumn);
          const questionX = config.questionsStartX + col * (config.horizontalSpacingBetweenOptions * optionCount + config.boxSize + config.optionOffsetX + 12);
          const questionY = config.answerStartY + row * config.verticalSpacingBetweenQuestions;
          
          let detected = null;
          let maxRatio = 0;
          
          for (let j = 0; j < optionCount && j < options.length; j++) {
            const optionX = questionX + config.boxSize + config.optionOffsetX + j * config.horizontalSpacingBetweenOptions;
            const roi = binary.roi(new cv.Rect(optionX, questionY, config.boxSize, config.boxSize));
            const totalPixels = roi.cols * roi.rows;
            const filledPixels = cv.countNonZero(roi);
            roi.delete();
            
            const ratio = filledPixels / totalPixels;
            if (ratio > maxRatio && ratio > config.PROCESSING.OPTION_THRESHOLD) {
              maxRatio = ratio;
              detected = j;
            }
          }
          
          if (detected !== null) {
            state.studentAnswers[i] = { answer: options[detected], score: maxRatio };
          }
        }
        
        gray.delete();
        binary.delete();
        this.updateResults();
      }

      static updateResults() {
        if (state.answerKey.length === 0) {
          this.showFloatingMessage("请先设置答案");
          return;
        }
        
        const scorePerQuestion = parseInt(document.getElementById('scorePerQuestion').value) || 1;
        let totalScore = 0;
        const stats = [];
        
        state.studentAnswers.forEach((item, index) => {
          const selected = item.answer || '未作答';
          const isCorrect = selected === state.answerKey[index];
          if (isCorrect) totalScore += scorePerQuestion;
          stats.push({
            question: index + 1,
            correct: isCorrect,
            selected: selected,
            correctAnswer: state.answerKey[index]
          });
        });
        
        document.getElementById('overlayTotalScore').textContent = totalScore;
        const overlayStats = document.getElementById('overlayQuestionStats');
        overlayStats.innerHTML = '';
        
        stats.forEach(item => {
          const div = document.createElement('div');
          div.textContent = `Q${item.question}: ${item.selected} ${item.correct ? '✓' : '✗'}`;
          overlayStats.appendChild(div);
        });
        
        document.getElementById('results').classList.add('hide');
      }

      static updatePerformanceStats(startTime) {
        const latency = performance.now() - startTime;
        console.log(`Processing latency: ${latency.toFixed(1)}ms`);
      }
    }

    // Event listeners
    document.getElementById('generateBtn').addEventListener('click', generateAnswerSheet);
    document.getElementById('setAnswerKeyBtn').addEventListener('click', showAnswerKeyInput);
    document.getElementById('exportImgBtn').addEventListener('click', exportAnswerSheetAsImage);
    document.getElementById('startCameraBtn').addEventListener('click', () => AnswerSheetScanner.initializeCamera());
    document.getElementById('stopCameraBtn').addEventListener('click', stopCamera);
    document.getElementById('capturePhotoBtn').addEventListener('click', capturePhoto);
    document.getElementById('saveResultBtn').addEventListener('click', saveCurrentResult);
    document.getElementById('showCameraBtn').addEventListener('click', showCamera);
    document.getElementById('showAggregateBtn').addEventListener('click', displayAggregateStats);
    document.getElementById('hideAggregateBtn').addEventListener('click', hideAggregateStats);
    document.getElementById('toggleFullscreenBtn').addEventListener('click', toggleFullscreen);

    // Utility functions
    function showFloatingMessage(message) {
      const container = document.getElementById('floatingMessageContainer');
      const msgDiv = document.createElement('div');
      msgDiv.className = 'message';
      msgDiv.textContent = message;
      container.appendChild(msgDiv);
      
      setTimeout(() => {
        msgDiv.style.opacity = '0';
        setTimeout(() => container.removeChild(msgDiv), 500);
      }, 3000);
    }

    function generateAnswerSheet() {
      const questionCount = parseInt(document.getElementById('questionCount').value);
      const optionCount = parseInt(document.getElementById('optionCount').value);
      const studentIdDigits = parseInt(document.getElementById('studentIdDigits').value);
      const canvas = document.getElementById('answerSheetCanvas');
      const ctx = canvas.getContext('2d');
      const config = config.ANSWER_SHEET;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.font = "16px Arial";
      ctx.fillText("Answer Sheet Template", 20, 25);
      
      // Draw student ID section
      ctx.font = "12px Arial";
      ctx.fillText("Student ID:", 20, config.studentIdLabelY);
      const digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
      
      for (let i = 0; i < studentIdDigits; i++) {
        const startX = config.studentIdStartX + i * (config.studentIdBoxSize + config.studentIdBoxSpacing);
        for (let j = 0; j < digits.length; j++) {
          const startY = config.studentIdLabelY + 8 + j * (config.studentIdBoxSize + config.studentIdBoxSpacing);
          ctx.strokeRect(startX, startY, config.studentIdBoxSize, config.studentIdBoxSize);
          ctx.font = "7px Arial";
          ctx.fillText(digits[j], startX + 1, startY + config.studentIdBoxSize - 1);
        }
      }
      
      // Draw questions and options
      ctx.font = "10px Arial";
      for (let i = 0; i < questionCount; i++) {
        const row = i % config.questionsPerColumn;
        const col = Math.floor(i / config.questionsPerColumn);
        const questionX = config.questionsStartX + col * (config.columnSpacing + (optionCount * config.horizontalSpacingBetweenOptions + config.boxSize + config.optionOffsetX + 3));
        const questionY = config.answerStartY + row * config.verticalSpacingBetweenQuestions;
        ctx.fillText(`${i + 1}.`, questionX, questionY + config.boxSize / 2 + 2);
        
        const optionsStartX = questionX + config.boxSize + config.optionOffsetX;
        const options = ['A', 'B', 'C', 'D'];
        
        for (let j = 0; j < optionCount && j < options.length; j++) {
          const optionX = optionsStartX + j * config.horizontalSpacingBetweenOptions;
          ctx.strokeRect(optionX, questionY, config.boxSize, config.boxSize);
          ctx.fillText(options[j], optionX + 1, questionY + config.boxSize / 2 + 2);
        }
      }
      
      // Draw markers
      ctx.fillStyle = "black";
      ctx.fillRect(config.markerMargin, config.markerMargin, config.markerSize, config.markerSize);
      ctx.fillRect(config.sheetWidth - config.markerMargin - config.markerSize, config.markerMargin, config.markerSize, config.markerSize);
      ctx.fillRect(config.markerMargin, config.sheetHeight / 2 - config.markerMargin - config.markerSize + 10, config.markerSize, config.markerSize);
      ctx.fillRect(config.sheetWidth - config.markerMargin - config.markerSize, config.sheetHeight / 2 - config.markerMargin - config.markerSize + 10, config.markerSize, config.markerSize);
      
      document.getElementById('answerSheetContainer').style.display = 'block';
      document.getElementById('cameraContainer').classList.add('hide');
      document.getElementById('results').classList.add('hide');
      document.getElementById('aggregate').classList.add('hide');
    }

    function showAnswerKeyInput() {
      const questionCount = parseInt(document.getElementById('questionCount').value) || 10;
      const input = prompt(`输入答案键（例如：A,B,C,A,... 共${questionCount}题）：`);
      
      if (input) {
        state.answerKey = input.toUpperCase().split(',').slice(0, questionCount);
        showFloatingMessage("答案键已设置");
      }
    }

    function exportAnswerSheetAsImage() {
      const canvas = document.getElementById('answerSheetCanvas');
      const imgData = canvas.toDataURL("image/png");
      const link = document.createElement('a');
      link.download = 'answer_sheet.png';
      link.href = imgData;
      link.click();
    }

    function showCamera() {
      document.getElementById('cameraContainer').classList.remove('hide');
    }

    function stopCamera() {
      if (state.videoStream) {
        state.videoStream.getTracks().forEach(track => track.stop());
        state.videoStream = null;
        state.isCameraActive = false;
        document.getElementById('cameraPreview').srcObject = null;
        document.getElementById('cameraOverlayResults').style.display = 'none';
      }
    }

    function capturePhoto() {
      if (!state.isCameraActive || !state.opencvReady) {
        showFloatingMessage("摄像头未激活或OpenCV未准备好");
        return;
      }
      
      const video = document.getElementById('cameraPreview');
      const captureCanvas = document.getElementById('captureCanvas');
      const ctx = captureCanvas.getContext('2d');
      ctx.drawImage(video, 0, 0, captureCanvas.width, captureCanvas.height);
      AnswerSheetScanner.processFrame();
    }

    function saveCurrentResult() {
      if (state.studentAnswers.length === 0) {
        showFloatingMessage('没有有效的扫描结果');
        return;
      }
      
      const scorePerQuestion = parseInt(document.getElementById('scorePerQuestion').value) || 1;
      let totalScore = 0;
      const answers = state.studentAnswers.map((item, index) => {
        const selected = item.answer || '未作答';
        if (selected === state.answerKey[index]) totalScore += scorePerQuestion;
        return selected;
      });
      
      state.allStudentResults.push({ answers, totalScore });
      showFloatingMessage(`结果已保存。总结果数：${state.allStudentResults.length}`);
    }

    function displayAggregateStats() {
      if (state.allStudentResults.length === 0) {
        showFloatingMessage('没有保存的扫描结果');
        return;
      }
      
      const questionCount = parseInt(document.getElementById('questionCount').value) || 10;
      const stats = Array(questionCount).fill(0);
      
      state.allStudentResults.forEach(result => {
        result.answers.forEach((ans, index) => {
          if (ans === state.answerKey[index]) stats[index]++;
        });
      });
      
      const aggregateContainer = document.getElementById('aggregateStats');
      aggregateContainer.innerHTML = '';
      
      for (let i = 0; i < questionCount; i++) {
        const correctCount = stats[i];
        const rate = ((correctCount / state.allStudentResults.length) * 100).toFixed(1);
        const div = document.createElement('div');
        div.className = 'aggregate-item';
        div.textContent = `Q${i+1}: ${rate}% (${correctCount}/${state.allStudentResults.length})`;
        aggregateContainer.appendChild(div);
      }
      
      document.getElementById('aggregate').classList.remove('hide');
    }

    function hideAggregateStats() {
      document.getElementById('aggregate').classList.add('hide');
    }

    function toggleFullscreen() {
      const cameraContainer = document.getElementById('cameraContainer');
      if (cameraContainer.classList.contains('fullscreen')) {
        cameraContainer.classList.remove('fullscreen');
        document.body.style.overflow = 'auto';
      } else {
        cameraContainer.classList.add('fullscreen');
        document.body.style.overflow = 'hidden';
      }
    }

    function onOpenCvReady() {
      state.opencvReady = true;
      showFloatingMessage("OpenCV.js已加载");
    }

    document.addEventListener('DOMContentLoaded', () => {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert('您的浏览器不支持摄像头功能。');
        return;
      }
      generateAnswerSheet();
    });
  </script>
</body>
</html>
