<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Answer Sheet Scanner</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            width: 90%;
            max-width: 800px;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        h1 {
            color: #333;
        }

        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            background-color: #007bff;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
        }

        button:hover {
            background-color: #0056b3;
        }

        #answerSheetContainer {
            display: none;
            margin-top: 20px;
        }

        #answerSheetCanvas {
            border: 1px solid #ccc;
            max-width: 100%;
            height: auto;
        }

        #cameraContainer {
            position: relative;
            display: none;
            margin-top: 20px;
        }

        #cameraPreview {
            width: 100%;
            max-height: 70vh; /* 限制高度防止溢出 */
            object-fit: contain; /* 保持比例完整显示 */
            background: #000;
        }

        #cameraOverlayGuide {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }

        #cameraOverlayText {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ff00;
            font-size: 1.2em;
            text-shadow: 1px 1px 2px black;
            z-index: 11; /* 确保在引导层上方 */
            text-align: center;
        }

        #captureCanvas {
            display: none;
        }

        #binaryCanvas {
            display: none;
            border: 1px solid #eee;
            margin-top: 10px;
            max-width: 100%;
            height: auto;
        }

        #results {
            display: none;
            margin-top: 20px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 5px;
            text-align: left;
        }

        #results h2 {
            margin-top: 0;
            color: #333;
        }

        .question-result {
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 4px;
        }

        #aggregate {
            display: none;
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            text-align: left;
        }

        #aggregate h2 {
            margin-top: 0;
            color: #333;
        }

        .aggregate-item {
            padding: 8px;
            margin-bottom: 5px;
            border-bottom: 1px solid #dee2e6;
        }

        .aggregate-item:last-child {
            border-bottom: none;
        }

        .hide {
            display: none !important;
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
        }

        #cameraOverlayResults {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 8px;
            border-radius: 5px;
            z-index: 12;
        }
    </style>
</head>
<body>
    <div id="loading" class="hide">Loading OpenCV.js ...</div>
    <div class="container">
        <h1>Answer Sheet Scanner</h1>
        <button id="generateSheetBtn">Generate Answer Sheet</button>
        <button id="setAnswerKeyBtn">Set Answer Key</button>
        <button id="exportSheetBtn">Export Answer Sheet as Image</button>
        <br>
        <label for="questionCount">Question Count:</label>
        <input type="number" id="questionCount" value="10" min="1">
        <label for="optionCount">Option Count:</label>
        <input type="number" id="optionCount" value="4" min="1" max="6">
        <label for="scorePerQuestion">Score per Question:</label>
        <input type="number" id="scorePerQuestion" value="1" min="0">
        <br>
        <button id="showCameraBtn">Show Camera</button>
        <button id="stopCameraBtn" class="hide">Stop Camera</button>
        <button id="captureBtn">Capture & Scan</button>
        <button id="saveResultBtn">Save Result</button>
        <button id="showAggregateBtn">Show All Results</button>
        <button id="hideAggregateBtn" class="hide">Hide All Results</button>
        <button id="toggleFullscreenBtn">Toggle Fullscreen</button>

        <div id="answerSheetContainer">
            <h2>Answer Sheet</h2>
            <canvas id="answerSheetCanvas"></canvas>
        </div>

        <div id="cameraContainer" class="hide">
            <canvas id="cameraOverlayGuide"></canvas>
            <video id="cameraPreview" autoplay playsinline></video>
            <div id="cameraOverlayText">请将答题卡对准绿色框区域，保持光线充足</div>
            <div id="cameraOverlayResults">Total Score: <span id="overlayTotalScore">0</span></div>
            <canvas id="captureCanvas" width="640" height="480"></canvas>
            <canvas id="binaryCanvas"></canvas>
        </div>

        <div id="results" class="hide">
            <h2>Scan Results</h2>
            <div id="questionStats"></div>
            <p>Total Score: <span id="totalScore">0</span></p>
        </div>

        <div id="aggregate" class="hide">
            <h2>Aggregate Statistics</h2>
            <div id="aggregateStats"></div>
        </div>
    </div>

    <dialog id="answerKeyDialog">
        <h2>Set Answer Key</h2>
        <label for="answerKeyInput">Enter Answer Key (comma-separated, e.g., A,B,C):</label><br>
        <input type="text" id="answerKeyInput"><br><br>
        <button id="setKeyConfirmBtn">Confirm Answer Key</button>
        <button id="setKeyCancelBtn">Cancel</button>
    </dialog>

    <script>
        (function() {
            "use strict";

            const ANSWER_SHEET_CONFIG = {
                sheetWidth: 595, // A4 width in pixels (72 DPI)
                sheetHeight: 842, // A4 height in pixels (72 DPI)
                markerSize: 20,
                markerMargin: 20,
                studentIdLabelY: 50,
                studentIdStartX: 50,
                studentIdBoxSize: 15,
                studentIdBoxSpacing: 5,
                studentIdDigits: 10,
                answerStartY: 150,
                questionsStartX: 50,
                boxSize: 15,
                horizontalSpacingBetweenOptions: 25,
                verticalSpacingBetweenQuestions: 30,
                optionOffsetX: 10,
                questionsPerColumn: 22, // Adjusted for full A4 sheet
                columnSpacing: 20
            };

            const OPTION_THRESHOLD = 0.6; // Threshold for considering an option filled

            const AppState = {
                opencvReady: false,
                isCameraActive: false,
                videoStream: null,
                answerKey: [],
                studentAnswers: [],
            };

            let scanningInterval; // To hold the interval for continuous scanning

            function debugLog(message) {
                console.log("[Scanner]", message);
            }

            function onOpenCvReady() {
                debugLog("OpenCV.js is ready.");
                AppState.opencvReady = true;
                document.getElementById('loading').style.display = 'none';
            }

            function waitForOpenCvReady() {
                return new Promise(resolve => {
                    if (AppState.opencvReady) {
                        resolve();
                    } else {
                        const checkInterval = setInterval(() => {
                            if (AppState.opencvReady) {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 100);
                    }
                });
            }

            function generateAnswerSheet() {
                const canvas = document.getElementById('answerSheetCanvas');
                canvas.width = ANSWER_SHEET_CONFIG.sheetWidth;
                canvas.height = ANSWER_SHEET_CONFIG.sheetHeight;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = "black";
                ctx.lineWidth = 1;

                function drawSheetPart(offsetY) {
                    ctx.font = "12px Arial";
                    ctx.fillText("Student ID:", ANSWER_SHEET_CONFIG.markerMargin, ANSWER_SHEET_CONFIG.studentIdLabelY + offsetY);
                    const studentIdDigits = ANSWER_SHEET_CONFIG.studentIdDigits;
                    const digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
                    for (let i = 0; i < studentIdDigits; i++) {
                        const startX = ANSWER_SHEET_CONFIG.studentIdStartX + i * (ANSWER_SHEET_CONFIG.studentIdBoxSize + ANSWER_SHEET_CONFIG.studentIdBoxSpacing);
                        for (let j = 0; j < digits.length; j++) {
                            const startY = ANSWER_SHEET_CONFIG.studentIdLabelY + 8 + j * (ANSWER_SHEET_CONFIG.studentIdBoxSize + ANSWER_SHEET_CONFIG.studentIdBoxSpacing) + offsetY;
                            ctx.strokeRect(startX, startY, ANSWER_SHEET_CONFIG.studentIdBoxSize, ANSWER_SHEET_CONFIG.studentIdBoxSize);
                            ctx.font = "7px Arial";
                            ctx.fillText(digits[j], startX + 1, startY + ANSWER_SHEET_CONFIG.studentIdBoxSize - 1);
                        }
                    }
                    ctx.font = "10px Arial";
                    const questionCount = parseInt(document.getElementById('questionCount').value) || 10;
                    const optionCount = parseInt(document.getElementById('optionCount').value) || 4;
                    for (let i = 0; i < questionCount; i++) {
                        const row = i % ANSWER_SHEET_CONFIG.questionsPerColumn;
                        const col = Math.floor(i / ANSWER_SHEET_CONFIG.questionsPerColumn);
                        const questionX = ANSWER_SHEET_CONFIG.questionsStartX + col * (ANSWER_SHEET_CONFIG.columnSpacing + (optionCount * ANSWER_SHEET_CONFIG.horizontalSpacingBetweenOptions + ANSWER_SHEET_CONFIG.boxSize + ANSWER_SHEET_CONFIG.optionOffsetX + 3));
                        const questionY = ANSWER_SHEET_CONFIG.answerStartY + row * ANSWER_SHEET_CONFIG.verticalSpacingBetweenQuestions + offsetY;
                        ctx.fillText(`${i + 1}.`, questionX, questionY + ANSWER_SHEET_CONFIG.boxSize / 2 + 2);
                        const optionsStartX = questionX + ANSWER_SHEET_CONFIG.boxSize + ANSWER_SHEET_CONFIG.optionOffsetX;
                        const options = ['A', 'B', 'C', 'D', 'E', 'F'].slice(0, optionCount);
                        for (let j = 0; j < optionCount; j++) {
                            const optionX = optionsStartX + j * ANSWER_SHEET_CONFIG.horizontalSpacingBetweenOptions;
                            ctx.strokeRect(optionX, questionY, ANSWER_SHEET_CONFIG.boxSize, ANSWER_SHEET_CONFIG.boxSize);
                            ctx.fillText(options[j], optionX + 1, questionY + ANSWER_SHEET_CONFIG.boxSize / 2 + 2);
                        }
                    }
                    // Draw corner markers for perspective correction
                    ctx.fillStyle = "black";
                    ctx.fillRect(ANSWER_SHEET_CONFIG.markerMargin, ANSWER_SHEET_CONFIG.markerMargin + offsetY, ANSWER_SHEET_CONFIG.markerSize, ANSWER_SHEET_CONFIG.markerSize);
                    ctx.fillRect(ANSWER_SHEET_CONFIG.sheetWidth - ANSWER_SHEET_CONFIG.markerMargin - ANSWER_SHEET_CONFIG.markerSize, ANSWER_SHEET_CONFIG.markerMargin + offsetY, ANSWER_SHEET_CONFIG.markerSize, ANSWER_SHEET_CONFIG.markerSize);
                    ctx.fillRect(ANSWER_SHEET_CONFIG.markerMargin, ANSWER_SHEET_CONFIG.sheetHeight / 2 - ANSWER_SHEET_CONFIG.markerMargin - ANSWER_SHEET_CONFIG.markerSize + 10 + offsetY, ANSWER_SHEET_CONFIG.markerSize, ANSWER_SHEET_CONFIG.markerSize);
                    ctx.fillRect(ANSWER_SHEET_CONFIG.sheetWidth - ANSWER_SHEET_CONFIG.markerMargin - ANSWER_SHEET_CONFIG.markerSize, ANSWER_SHEET_CONFIG.sheetHeight / 2 - ANSWER_SHEET_CONFIG.markerMargin - ANSWER_SHEET_CONFIG.markerSize + 10 + offsetY, ANSWER_SHEET_CONFIG.markerSize, ANSWER_SHEET_CONFIG.markerSize);
                }
                drawSheetPart(0);
                drawSheetPart(ANSWER_SHEET_CONFIG.sheetHeight / 2);
                ctx.strokeStyle = "#ccc";
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, ANSWER_SHEET_CONFIG.sheetHeight / 2);
                ctx.lineTo(ANSWER_SHEET_CONFIG.sheetWidth, ANSWER_SHEET_CONFIG.sheetHeight / 2);
                ctx.stroke();
                ctx.setLineDash([]);
                document.getElementById('answerSheetContainer').style.display = 'block';
                document.getElementById('cameraContainer').classList.add('hide');
                document.getElementById('results').classList.add('hide');
                document.getElementById('aggregate').classList.add('hide');
            }

            function setAnswerKey() {
                const input = document.getElementById('answerKeyInput').value;
                const questionCount = parseInt(document.getElementById('questionCount').value) || 10;
                const optionCount = parseInt(document.getElementById('optionCount').value) || 4;
                const validOptions = ['A', 'B', 'C', 'D', 'E', 'F'].slice(0, optionCount);
                const answers = input.toUpperCase().split(',').map(s => s.trim()).slice(0, questionCount);
                const isValid = answers.every(ans => validOptions.includes(ans));
                if (isValid) {
                    AppState.answerKey = answers;
                    debugLog("Answer key set: " + AppState.answerKey.join(','));
                    document.getElementById('answerKeyDialog').close();
                } else {
                    alert(`Invalid answer key format. Please use comma-separated values (e.g., A,B,C) with valid options (${validOptions.join(', ')}).`);
                }
            }

            function exportAnswerSheetAsImage() {
                const canvas = document.getElementById('answerSheetCanvas');
                const originalWidth = canvas.width, originalHeight = canvas.height;
                // Increase resolution for export
                canvas.width = 2480;
                canvas.height = 3508;
                generateAnswerSheet();
                const imgData = canvas.toDataURL("image/png");
                const link = document.createElement('a');
                link.download = 'answer_sheet.png';
                link.href = imgData;
                link.click();
                // Restore original resolution
                canvas.width = originalWidth;
                canvas.height = originalHeight;
                generateAnswerSheet();
            }

            function orderPoints(points) {
                // Sort points by y-coordinate
                points.sort((a, b) => a.y - b.y);
                const topLeft = points.slice(0, 2).sort((a, b) => a.x - b.x)[0];
                const topRight = points.slice(0, 2).sort((a, b) => a.x - b.x)[1];
                const bottomLeft = points.slice(2, 4).sort((a, b) => a.x - b.x)[0];
                const bottomRight = points.slice(2, 4).sort((a, b) => a.x - b.x)[1];
                return [topLeft, topRight, bottomRight, bottomLeft];
            }

            function safeDelete(...mats) {
                mats.forEach(mat => {
                    if (mat && mat.delete) mat.delete();
                });
            }

            async function startCamera() {
                if (AppState.isCameraActive) return;
                const video = document.getElementById('cameraPreview');
                try {
                    AppState.videoStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
                    video.srcObject = AppState.videoStream;
                    AppState.isCameraActive = true;
                    video.classList.remove('hide');
                    document.getElementById('cameraContainer').classList.remove('hide');
                    document.getElementById('cameraOverlayResults').style.display = 'block';
                    document.getElementById('cameraOverlayText').style.display = 'block'; // 显示提示文字
                    document.getElementById('cameraOverlayGuide').style.display = 'block'; // 显示引导框
                    await waitForOpenCvReady();
                    debugLog("Camera started.");

                    // Start continuous scanning
                    scanningInterval = setInterval(processCameraFrame, 200); // Adjust interval as needed
                    drawFocusGuide(); // 绘制引导框
                } catch (err) {
                    alert(`Camera start failed: ${err.message}`);
                    debugLog(`Camera error: ${err.stack}`);
                }
            }

            function stopCamera() {
                if (AppState.isCameraActive) {
                    AppState.videoStream.getTracks().forEach(track => track.stop());
                    AppState.videoStream = null;
                    AppState.isCameraActive = false;
                    document.getElementById('cameraPreview').classList.add('hide');
                    document.getElementById('cameraOverlayResults').style.display = 'none';
                    document.getElementById('cameraOverlayText').style.display = 'none'; // 隐藏提示文字
                    document.getElementById('cameraOverlayGuide').style.display = 'none'; // 隐藏引导框
                    debugLog("Camera stopped.");

                    // Stop continuous scanning
                    clearInterval(scanningInterval);
                }
            }

            function drawFocusGuide() {
                const guideCanvas = document.getElementById('cameraOverlayGuide');
                const video = document.getElementById('cameraPreview');
                const guideCtx = guideCanvas.getContext('2d');

                // 动态匹配视频尺寸
                guideCanvas.width = video.videoWidth;
                guideCanvas.height = video.videoHeight;

                const width = guideCanvas.width;
                const height = guideCanvas.height;
                const guideWidth = width * 0.7; // 引导框宽度为视频70%
                const guideHeight = height * 0.5; // 引导框高度为视频50%
                const guideX = (width - guideWidth) / 2;
                const guideY = (height - guideHeight) / 2;

                guideCtx.clearRect(0, 0, width, height);

                // 绘制半透明背景（排除中心区域）
                guideCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                guideCtx.fillRect(0, 0, width, height); // 全屏背景
                guideCtx.clearRect(guideX, guideY, guideWidth, guideHeight); // 清空中心区域

                // 绘制高亮边框
                guideCtx.strokeStyle = '#00ff00';
                guideCtx.lineWidth = 3;
                guideCtx.setLineDash([10, 5]); // 虚线样式
                guideCtx.strokeRect(guideX, guideY, guideWidth, guideHeight);
            }

            async function processCameraFrame() {
                if (!AppState.isCameraActive || !AppState.opencvReady) {
                    return;
                }
                const video = document.getElementById('cameraPreview');
                const captureCanvas = document.getElementById('captureCanvas');
                captureCanvas.width = video.videoWidth;
                captureCanvas.height = video.videoHeight;
                const ctx = captureCanvas.getContext('2d');
                ctx.drawImage(video, 0, 0, captureCanvas.width, captureCanvas.height);
                processImageForScanning(captureCanvas, true); // Pass a flag for continuous mode
                drawFocusGuide(); // 绘制引导框
            }

            async function processImageForScanning(canvas, continuousMode = false) {
                if (!AppState.opencvReady) {
                    debugLog("OpenCV not ready for scanning.");
                    return;
                }
                let src = null, gray = null, equalized = null, binaryMarkers = null, contours = null, hierarchy = null;
                try {
                    src = cv.imread(canvas);

                    // Convert to grayscale and reduce noise
                    gray = new cv.Mat();
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                    cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);

                    // Improve contrast with histogram equalization
                    equalized = new cv.Mat();
                    cv.equalizeHist(gray, equalized);

                    // Adaptive thresholding for marker detection
                    binaryMarkers = new cv.Mat();
                    cv.adaptiveThreshold(equalized, binaryMarkers, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY, 11, 2);

                    // Apply a morphological open operation to remove noise
                    let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
                    cv.morphologyEx(binaryMarkers, binaryMarkers, cv.MORPH_OPEN, kernel);
                    kernel.delete();

                    contours = new cv.MatVector();
                    hierarchy = new cv.Mat();
                    cv.findContours(binaryMarkers, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                    let detectedMarkers = [];
                    const minArea = 50, maxArea = 300, approxFactor = 0.04;
                    for (let i = 0; i < contours.size(); i++) {
                        let contour = contours.get(i);
                        let area = cv.contourArea(contour);
                        if (area > minArea && area < maxArea) {
                            let approx = new cv.Mat();
                            let epsilon = approxFactor * cv.arcLength(contour, true);
                            cv.approxPolyDP(contour, approx, epsilon, true);
                            if (approx.rows === 4) {
                                let pts = [];
                                for (let j = 0; j < 4; j++) {
                                    pts.push({
                                        x: approx.intPtr(j, 0)[0],
                                        y: approx.intPtr(j, 0)[1]
                                    });
                                }
                                detectedMarkers.push(pts);
                                // For visual debugging: draw detected markers
                                if (continuousMode) {
                                    pts.forEach(pt => {
                                        cv.circle(src, new cv.Point(pt.x, pt.y), 4, new cv.Scalar(255, 0, 0, 255), -1);
                                    });
                                }
                            }
                            approx.delete();
                        }
                    }
                    debugLog(`Detected ${detectedMarkers.length} marker(s).`);

                    if (detectedMarkers.length === 4) {
                        // Calculate centroids for each detected marker
                        let centroids = detectedMarkers.map(marker => {
                            let sumX = 0, sumY = 0;
                            marker.forEach(pt => { sumX += pt.x; sumY += pt.y; });
                            return { x: sumX / marker.length, y: sumY / marker.length };
                        });

                        // Order the centroids for robust perspective correction
                        let orderedPts = orderPoints(centroids);

                        // Draw ordered points with larger red circles for better visibility
                        if (continuousMode) {
                            orderedPts.forEach(pt => {
                                // Increased circle radius to 8 pixels
                                cv.circle(src, new cv.Point(pt.x, pt.y), 8, new cv.Scalar(255, 0, 0, 255), -1);
                            });
                        }

                        const targetWidth = 595, targetHeight = 842;
                        let srcPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
                            orderedPts[0].x, orderedPts[0].y,
                            orderedPts[1].x, orderedPts[1].y,
                            orderedPts[2].x, orderedPts[2].y,
                            orderedPts[3].x, orderedPts[3].y
                        ]);
                        let dstPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
                            0, 0,
                            targetWidth, 0,
                            targetWidth, targetHeight / 2,
                            0, targetHeight / 2
                        ]);
                        let M = cv.getPerspectiveTransform(srcPts, dstPts);
                        let warped = new cv.Mat();
                        cv.warpPerspective(src, warped, M, new cv.Size(targetWidth, targetHeight / 2), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
                        processScannedOptions(warped, src, continuousMode); // Pass continuousMode
                        if (!continuousMode) {
                            cv.imshow('captureCanvas', src); // Only show on capture
                        }
                        safeDelete(warped, M, srcPts, dstPts);
                    } else if (continuousMode) {
                        // If no markers in continuous mode, still process the frame
                        let roi = src.roi(new cv.Rect(0, 0, src.cols, src.rows / 2));
                        processScannedOptions(roi, src, continuousMode);
                        roi.delete();
                    } else {
                        let roi = src.roi(new cv.Rect(0, 0, src.cols, src.rows / 2));
                        processScannedOptions(roi, src, continuousMode);
                        cv.imshow('captureCanvas', src); // Show on capture
                        roi.delete();
                    }

                } catch (error) {
                    console.error("Scanning error:", error);
                    if (continuousMode) {
                        // Avoid flooding with errors in continuous mode
                        debugLog("Error processing frame.");
                    } else {
                        debugLog("Error processing image, please try again.");
                    }
                } finally {
                    safeDelete(src, gray, equalized, binaryMarkers, contours, hierarchy);
                }
            }

            function processScannedOptions(processedImage, originalImage, continuousMode = false) {
                const questionCount = parseInt(document.getElementById('questionCount').value) || 10;
                const optionCount = parseInt(document.getElementById('optionCount').value) || 4;
                AppState.studentAnswers = Array.from({ length: questionCount }, () => ({ answer: null, score: 0 }));
                const config = ANSWER_SHEET_CONFIG;
                const options = ['A', 'B', 'C', 'D', 'E', 'F'].slice(0, optionCount);
                let gray = new cv.Mat(), binary = new cv.Mat();
                try {
                    cv.cvtColor(processedImage, gray, cv.COLOR_RGBA2GRAY, 0);
                    cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);
                    if (!continuousMode) {
                        cv.imshow('binaryCanvas', binary);
                        document.getElementById('binaryCanvas').classList.remove('hide');
                    }

                    const captureCanvas = document.getElementById('captureCanvas');
                    const captureCtx = captureCanvas.getContext('2d');
                    captureCtx.clearRect(0, 0, captureCanvas.width, captureCanvas.height);
                    captureCtx.drawImage(originalImage, 0, 0, captureCanvas.width, captureCanvas.height);

                    for (let i = 0; i < questionCount; i++) {
                        const row = i % config.questionsPerColumn;
                        const col = Math.floor(i / config.questionsPerColumn);
                        const questionX = config.questionsStartX + col * (config.columnSpacing + (optionCount * config.horizontalSpacingBetweenOptions + config.boxSize + config.optionOffsetX + 3));
                        const questionY = config.answerStartY + row * config.verticalSpacingBetweenQuestions;
                        let bestMatch = { option: null, fillRatio: 0 };

                        for (let j = 0; j < optionCount; j++) {
                            const optionX = questionX + j * config.horizontalSpacingBetweenOptions;
                            const roiRect = new cv.Rect(optionX, questionY, config.boxSize, config.boxSize);
                            let optionRoi = binary.roi(roiRect);
                            let filledPixels = cv.countNonZero(optionRoi);
                            optionRoi.delete();
                            const fillRatio = filledPixels / (config.boxSize * config.boxSize);

                            // 填充检测到的选项框（半透明绿色）
                            if (fillRatio > OPTION_THRESHOLD) {
                                captureCtx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                                captureCtx.fillRect(optionX, questionY, config.boxSize, config.boxSize);
                            }

                            // 绘制边框
                            captureCtx.strokeStyle = fillRatio > OPTION_THRESHOLD ? '#00ff00' : '#ff0000';
                            captureCtx.lineWidth = 2;
                            captureCtx.strokeRect(optionX, questionY, config.boxSize, config.boxSize);
                        }
                        AppState.studentAnswers[i].answer = bestMatch.option;
                    }
                    calculateScore(originalImage, continuousMode); // Pass continuousMode
                } catch (error) {
                    console.error("Error processing scanned options:", error);
                    if (continuousMode) {
                        debugLog("Error processing scan.");
                    } else {
                        debugLog("Error processing scanned options.");
                    }
                } finally {
                    safeDelete(gray, binary);
                }
            }


            function calculateScore(originalImage, continuousMode = false) {
                if (AppState.answerKey.length === 0) {
                    if (!continuousMode) {
                        alert('Please set the answer key first.');
                    }
                    return;
                }
                let score = 0;
                const scorePerQuestion = parseInt(document.getElementById('scorePerQuestion').value) || 1;
                const overlayQuestionStatsDiv = document.getElementById('overlayQuestionStats');
                overlayQuestionStatsDiv.innerHTML = '';

                const captureCanvas = document.getElementById('captureCanvas');
                const captureCtx = captureCanvas.getContext('2d');
                captureCtx.clearRect(0, 0, captureCanvas.width, captureCanvas.height);
                captureCtx.drawImage(originalImage, 0, 0, captureCanvas.width, captureCanvas.height);

                AppState.studentAnswers.forEach((ans, index) => {
                    const isCorrect = ans.answer === AppState.answerKey[index];
                    if (isCorrect) {
                        score += scorePerQuestion;
                        ans.score = scorePerQuestion;
                        captureCtx.fillStyle = 'green';
                    } else {
                        ans.score = 0;
                        captureCtx.fillStyle = 'red';
                    }
                    const overlayResultDiv = document.createElement('div');
                    overlayResultDiv.innerHTML = `${index + 1}: <span class="math-inline">\{ans\.answer \|\| '\-'\} \(</span>{isCorrect ? 'OK' : 'X'})`;
                    overlayQuestionStatsDiv.appendChild(overlayResultDiv);

                    // 在选项旁显示正确性图标
                    const row = index % ANSWER_SHEET_CONFIG.questionsPerColumn;
                    const col = Math.floor(index / ANSWER_SHEET_CONFIG.questionsPerColumn);
                    const questionX = config.questionsStartX + col * (config.columnSpacing + (config.horizontalSpacingBetweenOptions * (parseInt(document.getElementById('optionCount').value) || 4) + 30));
                    const questionY = config.answerStartY + row * config.verticalSpacingBetweenQuestions;

                    captureCtx.font = "bold 16px Arial";
                    captureCtx.fillStyle = isCorrect ? '#00ff00' : '#ff0000';
                    captureCtx.fillText(isCorrect ? '✓' : '✗', questionX - 25, questionY + 15);
                });
                document.getElementById('overlayTotalScore').textContent = score;
                if (!continuousMode) {
                    document.getElementById('totalScore').textContent = score;
                    document.getElementById('results').classList.remove('hide');
                    document.getElementById('aggregate').classList.add('hide');
                }
            }
            function saveResult() {
                const resultsDiv = document.getElementById('questionStats');
                const score = document.getElementById('totalScore').textContent;
                const resultText = `Score: ${score}\nQuestion Results:\n${resultsDiv.innerText}`;
                const blob = new Blob([resultText], { type: 'text/plain;charset=utf-8' });
                const link = document.createElement('a');
                link.download = 'scan_result.txt';
                link.href = URL.createObjectURL(blob);
                link.click();
            }

            function displayAggregateStats() {
                document.getElementById('aggregate').classList.remove('hide');
                document.getElementById('results').classList.add('hide');
                const statsDiv = document.getElementById('aggregateStats');
                statsDiv.innerHTML = 'Feature not implemented yet.';
            }

            function hideAggregateStats() {
                document.getElementById('aggregate').classList.add('hide');
                document.getElementById('results').classList.remove('hide');
            }

            function toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        alert(`Error attempting to enable full-screen mode: ${err.message}`);
                    });
                } else {
                    document.exitFullscreen();
                }
            }

            document.addEventListener('DOMContentLoaded', () => {
                document.getElementById('generateSheetBtn').addEventListener('click', generateAnswerSheet);
                document.getElementById('setAnswerKeyBtn').addEventListener('click', () => document.getElementById('answerKeyDialog').showModal());
                document.getElementById('setKeyConfirmBtn').addEventListener('click', setAnswerKey);
                document.getElementById('setKeyCancelBtn').addEventListener('click', () => document.getElementById('answerKeyDialog').close());
                document.getElementById('exportSheetBtn').addEventListener('click', exportAnswerSheetAsImage);
                document.getElementById('showCameraBtn').addEventListener('click', startCamera);
                document.getElementById('stopCameraBtn').addEventListener('click', stopCamera);
                document.getElementById('captureBtn').addEventListener('click', capturePhoto);
                document.getElementById('saveResultBtn').addEventListener('click', saveResult);
                document.getElementById('showAggregateBtn').addEventListener('click', displayAggregateStats);
                document.getElementById('hideAggregateBtn').addEventListener('click', hideAggregateStats);
                document.getElementById('toggleFullscreenBtn').addEventListener('click', toggleFullscreen);

                // Append the text overlay to the camera container
                const cameraContainer = document.getElementById('cameraContainer');
                const overlayText = document.createElement('div');
                overlayText.id = 'cameraOverlayText';
                overlayText.textContent = '请将答题卡对准绿色框区域，保持光线充足';
                cameraContainer.appendChild(overlayText);
                overlayText.style.display = 'none'; // Initially hide

                // Append the guide canvas to the camera container
                const overlayGuide = document.createElement('canvas');
                overlayGuide.id = 'cameraOverlayGuide';
                cameraContainer.appendChild(overlayGuide);
                overlayGuide.style.display = 'none'; // Initially hide
            });

            generateAnswerSheet();
            document.getElementById('loading').style.display = 'flex';
        })();
    </script>
</body>
</html>
